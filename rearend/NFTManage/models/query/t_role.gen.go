// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"yqnft/NFTManage/models/model"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newTRole(db *gorm.DB) tRole {
	_tRole := tRole{}

	_tRole.tRoleDo.UseDB(db)
	_tRole.tRoleDo.UseModel(&model.TRole{})

	tableName := _tRole.tRoleDo.TableName()
	_tRole.ALL = field.NewAsterisk(tableName)
	_tRole.ID = field.NewString(tableName, "id")
	_tRole.Name = field.NewString(tableName, "name")
	_tRole.Code = field.NewString(tableName, "code")
	_tRole.Pid = field.NewString(tableName, "pid")
	_tRole.PrivateOrg = field.NewInt64(tableName, "privateOrg")
	_tRole.RoleOrgType = field.NewInt64(tableName, "roleOrgType")
	_tRole.OrgID = field.NewString(tableName, "orgId")
	_tRole.ShareRole = field.NewInt64(tableName, "shareRole")
	_tRole.CreateTime = field.NewTime(tableName, "createTime")
	_tRole.CreateUserID = field.NewString(tableName, "createUserId")
	_tRole.UpdateTime = field.NewTime(tableName, "updateTime")
	_tRole.UpdateUserID = field.NewString(tableName, "updateUserId")
	_tRole.Sortno = field.NewInt64(tableName, "sortno")
	_tRole.Remark = field.NewString(tableName, "remark")
	_tRole.Active = field.NewInt64(tableName, "active")
	_tRole.IndexPage = field.NewString(tableName, "indexPage")
	_tRole.Bak1 = field.NewString(tableName, "bak1")
	_tRole.Bak2 = field.NewString(tableName, "bak2")
	_tRole.Bak3 = field.NewString(tableName, "bak3")
	_tRole.Bak4 = field.NewString(tableName, "bak4")
	_tRole.Bak5 = field.NewString(tableName, "bak5")

	_tRole.fillFieldMap()

	return _tRole
}

type tRole struct {
	tRoleDo tRoleDo

	ALL          field.Asterisk
	ID           field.String // 角色ID
	Name         field.String // 角色名称
	Code         field.String // 权限编码
	Pid          field.String // 上级角色ID,暂时不实现
	PrivateOrg   field.Int64  // 角色的部门是否私有,0否,1是,默认0.当角色私有时,菜单只使用此角色的部门权限,不再扩散到全局角色权限,用于设置特殊的菜单权限.公共权限时部门主管有所管理部门的数据全权限,无论角色是否分配. 私有部门权限时,严格按照配置的数据执行,部门主管可能没有部门权限.
	RoleOrgType  field.Int64  // 0自己的数据,1所在部门,2所在部门及子部门数据,3.自定义部门数据,4.全部数据权限
	OrgID        field.String // 角色的归属部门,只有归属部门的主管和上级主管才可以管理角色,其他人员只能增加归属到角色的人员.不能选择部门或则其他操作,只能添加人员,不然存在提权风险,例如 员工角色下有1000人, 如果给 角色 设置了部门,那这1000人都起效了.
	ShareRole    field.Int64  // 角色是否共享,0否 1是,默认0,共享的角色可以被下级部门直接使用,但是下级只能添加人员,不能设置其他属性.共享的角色一般只设置roleOrgType,并不设定部门.
	CreateTime   field.Time
	CreateUserID field.String
	UpdateTime   field.Time
	UpdateUserID field.String
	Sortno       field.Int64  // 排序,查询时倒叙排列
	Remark       field.String // 备注
	Active       field.Int64  // 是否有效(0否,1是)
	IndexPage    field.String // 是否有效(0否,1是)
	Bak1         field.String
	Bak2         field.String
	Bak3         field.String
	Bak4         field.String
	Bak5         field.String

	fieldMap map[string]field.Expr
}

func (t tRole) Table(newTableName string) *tRole {
	t.tRoleDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t tRole) As(alias string) *tRole {
	t.tRoleDo.DO = *(t.tRoleDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *tRole) updateTableName(table string) *tRole {
	t.ALL = field.NewAsterisk(table)
	t.ID = field.NewString(table, "id")
	t.Name = field.NewString(table, "name")
	t.Code = field.NewString(table, "code")
	t.Pid = field.NewString(table, "pid")
	t.PrivateOrg = field.NewInt64(table, "privateOrg")
	t.RoleOrgType = field.NewInt64(table, "roleOrgType")
	t.OrgID = field.NewString(table, "orgId")
	t.ShareRole = field.NewInt64(table, "shareRole")
	t.CreateTime = field.NewTime(table, "createTime")
	t.CreateUserID = field.NewString(table, "createUserId")
	t.UpdateTime = field.NewTime(table, "updateTime")
	t.UpdateUserID = field.NewString(table, "updateUserId")
	t.Sortno = field.NewInt64(table, "sortno")
	t.Remark = field.NewString(table, "remark")
	t.Active = field.NewInt64(table, "active")
	t.IndexPage = field.NewString(table, "indexPage")
	t.Bak1 = field.NewString(table, "bak1")
	t.Bak2 = field.NewString(table, "bak2")
	t.Bak3 = field.NewString(table, "bak3")
	t.Bak4 = field.NewString(table, "bak4")
	t.Bak5 = field.NewString(table, "bak5")

	t.fillFieldMap()

	return t
}

func (t *tRole) WithContext(ctx context.Context) ITRoleDo { return t.tRoleDo.WithContext(ctx) }

func (t tRole) TableName() string { return t.tRoleDo.TableName() }

func (t tRole) Alias() string { return t.tRoleDo.Alias() }

func (t *tRole) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *tRole) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 21)
	t.fieldMap["id"] = t.ID
	t.fieldMap["name"] = t.Name
	t.fieldMap["code"] = t.Code
	t.fieldMap["pid"] = t.Pid
	t.fieldMap["privateOrg"] = t.PrivateOrg
	t.fieldMap["roleOrgType"] = t.RoleOrgType
	t.fieldMap["orgId"] = t.OrgID
	t.fieldMap["shareRole"] = t.ShareRole
	t.fieldMap["createTime"] = t.CreateTime
	t.fieldMap["createUserId"] = t.CreateUserID
	t.fieldMap["updateTime"] = t.UpdateTime
	t.fieldMap["updateUserId"] = t.UpdateUserID
	t.fieldMap["sortno"] = t.Sortno
	t.fieldMap["remark"] = t.Remark
	t.fieldMap["active"] = t.Active
	t.fieldMap["indexPage"] = t.IndexPage
	t.fieldMap["bak1"] = t.Bak1
	t.fieldMap["bak2"] = t.Bak2
	t.fieldMap["bak3"] = t.Bak3
	t.fieldMap["bak4"] = t.Bak4
	t.fieldMap["bak5"] = t.Bak5
}

func (t tRole) clone(db *gorm.DB) tRole {
	t.tRoleDo.ReplaceDB(db)
	return t
}

type tRoleDo struct{ gen.DO }

type ITRoleDo interface {
	gen.SubQuery
	Debug() ITRoleDo
	WithContext(ctx context.Context) ITRoleDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	As(alias string) gen.Dao
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITRoleDo
	Not(conds ...gen.Condition) ITRoleDo
	Or(conds ...gen.Condition) ITRoleDo
	Select(conds ...field.Expr) ITRoleDo
	Where(conds ...gen.Condition) ITRoleDo
	Order(conds ...field.Expr) ITRoleDo
	Distinct(cols ...field.Expr) ITRoleDo
	Omit(cols ...field.Expr) ITRoleDo
	Join(table schema.Tabler, on ...field.Expr) ITRoleDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITRoleDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITRoleDo
	Group(cols ...field.Expr) ITRoleDo
	Having(conds ...gen.Condition) ITRoleDo
	Limit(limit int) ITRoleDo
	Offset(offset int) ITRoleDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITRoleDo
	Unscoped() ITRoleDo
	Create(values ...*model.TRole) error
	CreateInBatches(values []*model.TRole, batchSize int) error
	Save(values ...*model.TRole) error
	First() (*model.TRole, error)
	Take() (*model.TRole, error)
	Last() (*model.TRole, error)
	Find() ([]*model.TRole, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TRole, err error)
	FindInBatches(result *[]*model.TRole, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.TRole) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITRoleDo
	Assign(attrs ...field.AssignExpr) ITRoleDo
	Joins(fields ...field.RelationField) ITRoleDo
	Preload(fields ...field.RelationField) ITRoleDo
	FirstOrInit() (*model.TRole, error)
	FirstOrCreate() (*model.TRole, error)
	FindByPage(offset int, limit int) (result []*model.TRole, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITRoleDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t tRoleDo) Debug() ITRoleDo {
	return t.withDO(t.DO.Debug())
}

func (t tRoleDo) WithContext(ctx context.Context) ITRoleDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t tRoleDo) ReadDB() ITRoleDo {
	return t.Clauses(dbresolver.Read)
}

func (t tRoleDo) WriteDB() ITRoleDo {
	return t.Clauses(dbresolver.Write)
}

func (t tRoleDo) Clauses(conds ...clause.Expression) ITRoleDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t tRoleDo) Returning(value interface{}, columns ...string) ITRoleDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t tRoleDo) Not(conds ...gen.Condition) ITRoleDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t tRoleDo) Or(conds ...gen.Condition) ITRoleDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t tRoleDo) Select(conds ...field.Expr) ITRoleDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t tRoleDo) Where(conds ...gen.Condition) ITRoleDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t tRoleDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) ITRoleDo {
	return t.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (t tRoleDo) Order(conds ...field.Expr) ITRoleDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t tRoleDo) Distinct(cols ...field.Expr) ITRoleDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t tRoleDo) Omit(cols ...field.Expr) ITRoleDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t tRoleDo) Join(table schema.Tabler, on ...field.Expr) ITRoleDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t tRoleDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITRoleDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t tRoleDo) RightJoin(table schema.Tabler, on ...field.Expr) ITRoleDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t tRoleDo) Group(cols ...field.Expr) ITRoleDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t tRoleDo) Having(conds ...gen.Condition) ITRoleDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t tRoleDo) Limit(limit int) ITRoleDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t tRoleDo) Offset(offset int) ITRoleDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t tRoleDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITRoleDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t tRoleDo) Unscoped() ITRoleDo {
	return t.withDO(t.DO.Unscoped())
}

func (t tRoleDo) Create(values ...*model.TRole) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t tRoleDo) CreateInBatches(values []*model.TRole, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t tRoleDo) Save(values ...*model.TRole) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t tRoleDo) First() (*model.TRole, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TRole), nil
	}
}

func (t tRoleDo) Take() (*model.TRole, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TRole), nil
	}
}

func (t tRoleDo) Last() (*model.TRole, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TRole), nil
	}
}

func (t tRoleDo) Find() ([]*model.TRole, error) {
	result, err := t.DO.Find()
	return result.([]*model.TRole), err
}

func (t tRoleDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TRole, err error) {
	buf := make([]*model.TRole, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t tRoleDo) FindInBatches(result *[]*model.TRole, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t tRoleDo) Attrs(attrs ...field.AssignExpr) ITRoleDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t tRoleDo) Assign(attrs ...field.AssignExpr) ITRoleDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t tRoleDo) Joins(fields ...field.RelationField) ITRoleDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t tRoleDo) Preload(fields ...field.RelationField) ITRoleDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t tRoleDo) FirstOrInit() (*model.TRole, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TRole), nil
	}
}

func (t tRoleDo) FirstOrCreate() (*model.TRole, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TRole), nil
	}
}

func (t tRoleDo) FindByPage(offset int, limit int) (result []*model.TRole, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t tRoleDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t tRoleDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t tRoleDo) Delete(models ...*model.TRole) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *tRoleDo) withDO(do gen.Dao) *tRoleDo {
	t.DO = *do.(*gen.DO)
	return t
}
