// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"yqnft/NFTManage/models/model"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newNftWorksPrice(db *gorm.DB) nftWorksPrice {
	_nftWorksPrice := nftWorksPrice{}

	_nftWorksPrice.nftWorksPriceDo.UseDB(db)
	_nftWorksPrice.nftWorksPriceDo.UseModel(&model.NftWorksPrice{})

	tableName := _nftWorksPrice.nftWorksPriceDo.TableName()
	_nftWorksPrice.ALL = field.NewAsterisk(tableName)
	_nftWorksPrice.ID = field.NewString(tableName, "id")
	_nftWorksPrice.WorksID = field.NewString(tableName, "worksId")
	_nftWorksPrice.DateTime = field.NewTime(tableName, "dateTime")
	_nftWorksPrice.Price = field.NewFloat64(tableName, "price")
	_nftWorksPrice.Ratio = field.NewString(tableName, "ratio")
	_nftWorksPrice.CreateTime = field.NewTime(tableName, "createTime")
	_nftWorksPrice.UpdateTime = field.NewTime(tableName, "updateTime")
	_nftWorksPrice.Bak1 = field.NewString(tableName, "bak1")
	_nftWorksPrice.Bak2 = field.NewString(tableName, "bak2")
	_nftWorksPrice.Bak3 = field.NewString(tableName, "bak3")

	_nftWorksPrice.fillFieldMap()

	return _nftWorksPrice
}

type nftWorksPrice struct {
	nftWorksPriceDo nftWorksPriceDo

	ALL        field.Asterisk
	ID         field.String  // 唯一标识
	WorksID    field.String  // 作品标识
	DateTime   field.Time    // 时间
	Price      field.Float64 // 价格
	Ratio      field.String  // 浮动比例%
	CreateTime field.Time
	UpdateTime field.Time
	Bak1       field.String
	Bak2       field.String
	Bak3       field.String

	fieldMap map[string]field.Expr
}

func (n nftWorksPrice) Table(newTableName string) *nftWorksPrice {
	n.nftWorksPriceDo.UseTable(newTableName)
	return n.updateTableName(newTableName)
}

func (n nftWorksPrice) As(alias string) *nftWorksPrice {
	n.nftWorksPriceDo.DO = *(n.nftWorksPriceDo.As(alias).(*gen.DO))
	return n.updateTableName(alias)
}

func (n *nftWorksPrice) updateTableName(table string) *nftWorksPrice {
	n.ALL = field.NewAsterisk(table)
	n.ID = field.NewString(table, "id")
	n.WorksID = field.NewString(table, "worksId")
	n.DateTime = field.NewTime(table, "dateTime")
	n.Price = field.NewFloat64(table, "price")
	n.Ratio = field.NewString(table, "ratio")
	n.CreateTime = field.NewTime(table, "createTime")
	n.UpdateTime = field.NewTime(table, "updateTime")
	n.Bak1 = field.NewString(table, "bak1")
	n.Bak2 = field.NewString(table, "bak2")
	n.Bak3 = field.NewString(table, "bak3")

	n.fillFieldMap()

	return n
}

func (n *nftWorksPrice) WithContext(ctx context.Context) INftWorksPriceDo {
	return n.nftWorksPriceDo.WithContext(ctx)
}

func (n nftWorksPrice) TableName() string { return n.nftWorksPriceDo.TableName() }

func (n nftWorksPrice) Alias() string { return n.nftWorksPriceDo.Alias() }

func (n *nftWorksPrice) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := n.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (n *nftWorksPrice) fillFieldMap() {
	n.fieldMap = make(map[string]field.Expr, 10)
	n.fieldMap["id"] = n.ID
	n.fieldMap["worksId"] = n.WorksID
	n.fieldMap["dateTime"] = n.DateTime
	n.fieldMap["price"] = n.Price
	n.fieldMap["ratio"] = n.Ratio
	n.fieldMap["createTime"] = n.CreateTime
	n.fieldMap["updateTime"] = n.UpdateTime
	n.fieldMap["bak1"] = n.Bak1
	n.fieldMap["bak2"] = n.Bak2
	n.fieldMap["bak3"] = n.Bak3
}

func (n nftWorksPrice) clone(db *gorm.DB) nftWorksPrice {
	n.nftWorksPriceDo.ReplaceDB(db)
	return n
}

type nftWorksPriceDo struct{ gen.DO }

type INftWorksPriceDo interface {
	gen.SubQuery
	Debug() INftWorksPriceDo
	WithContext(ctx context.Context) INftWorksPriceDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	As(alias string) gen.Dao
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) INftWorksPriceDo
	Not(conds ...gen.Condition) INftWorksPriceDo
	Or(conds ...gen.Condition) INftWorksPriceDo
	Select(conds ...field.Expr) INftWorksPriceDo
	Where(conds ...gen.Condition) INftWorksPriceDo
	Order(conds ...field.Expr) INftWorksPriceDo
	Distinct(cols ...field.Expr) INftWorksPriceDo
	Omit(cols ...field.Expr) INftWorksPriceDo
	Join(table schema.Tabler, on ...field.Expr) INftWorksPriceDo
	LeftJoin(table schema.Tabler, on ...field.Expr) INftWorksPriceDo
	RightJoin(table schema.Tabler, on ...field.Expr) INftWorksPriceDo
	Group(cols ...field.Expr) INftWorksPriceDo
	Having(conds ...gen.Condition) INftWorksPriceDo
	Limit(limit int) INftWorksPriceDo
	Offset(offset int) INftWorksPriceDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) INftWorksPriceDo
	Unscoped() INftWorksPriceDo
	Create(values ...*model.NftWorksPrice) error
	CreateInBatches(values []*model.NftWorksPrice, batchSize int) error
	Save(values ...*model.NftWorksPrice) error
	First() (*model.NftWorksPrice, error)
	Take() (*model.NftWorksPrice, error)
	Last() (*model.NftWorksPrice, error)
	Find() ([]*model.NftWorksPrice, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.NftWorksPrice, err error)
	FindInBatches(result *[]*model.NftWorksPrice, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.NftWorksPrice) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) INftWorksPriceDo
	Assign(attrs ...field.AssignExpr) INftWorksPriceDo
	Joins(fields ...field.RelationField) INftWorksPriceDo
	Preload(fields ...field.RelationField) INftWorksPriceDo
	FirstOrInit() (*model.NftWorksPrice, error)
	FirstOrCreate() (*model.NftWorksPrice, error)
	FindByPage(offset int, limit int) (result []*model.NftWorksPrice, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) INftWorksPriceDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (n nftWorksPriceDo) Debug() INftWorksPriceDo {
	return n.withDO(n.DO.Debug())
}

func (n nftWorksPriceDo) WithContext(ctx context.Context) INftWorksPriceDo {
	return n.withDO(n.DO.WithContext(ctx))
}

func (n nftWorksPriceDo) ReadDB() INftWorksPriceDo {
	return n.Clauses(dbresolver.Read)
}

func (n nftWorksPriceDo) WriteDB() INftWorksPriceDo {
	return n.Clauses(dbresolver.Write)
}

func (n nftWorksPriceDo) Clauses(conds ...clause.Expression) INftWorksPriceDo {
	return n.withDO(n.DO.Clauses(conds...))
}

func (n nftWorksPriceDo) Returning(value interface{}, columns ...string) INftWorksPriceDo {
	return n.withDO(n.DO.Returning(value, columns...))
}

func (n nftWorksPriceDo) Not(conds ...gen.Condition) INftWorksPriceDo {
	return n.withDO(n.DO.Not(conds...))
}

func (n nftWorksPriceDo) Or(conds ...gen.Condition) INftWorksPriceDo {
	return n.withDO(n.DO.Or(conds...))
}

func (n nftWorksPriceDo) Select(conds ...field.Expr) INftWorksPriceDo {
	return n.withDO(n.DO.Select(conds...))
}

func (n nftWorksPriceDo) Where(conds ...gen.Condition) INftWorksPriceDo {
	return n.withDO(n.DO.Where(conds...))
}

func (n nftWorksPriceDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) INftWorksPriceDo {
	return n.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (n nftWorksPriceDo) Order(conds ...field.Expr) INftWorksPriceDo {
	return n.withDO(n.DO.Order(conds...))
}

func (n nftWorksPriceDo) Distinct(cols ...field.Expr) INftWorksPriceDo {
	return n.withDO(n.DO.Distinct(cols...))
}

func (n nftWorksPriceDo) Omit(cols ...field.Expr) INftWorksPriceDo {
	return n.withDO(n.DO.Omit(cols...))
}

func (n nftWorksPriceDo) Join(table schema.Tabler, on ...field.Expr) INftWorksPriceDo {
	return n.withDO(n.DO.Join(table, on...))
}

func (n nftWorksPriceDo) LeftJoin(table schema.Tabler, on ...field.Expr) INftWorksPriceDo {
	return n.withDO(n.DO.LeftJoin(table, on...))
}

func (n nftWorksPriceDo) RightJoin(table schema.Tabler, on ...field.Expr) INftWorksPriceDo {
	return n.withDO(n.DO.RightJoin(table, on...))
}

func (n nftWorksPriceDo) Group(cols ...field.Expr) INftWorksPriceDo {
	return n.withDO(n.DO.Group(cols...))
}

func (n nftWorksPriceDo) Having(conds ...gen.Condition) INftWorksPriceDo {
	return n.withDO(n.DO.Having(conds...))
}

func (n nftWorksPriceDo) Limit(limit int) INftWorksPriceDo {
	return n.withDO(n.DO.Limit(limit))
}

func (n nftWorksPriceDo) Offset(offset int) INftWorksPriceDo {
	return n.withDO(n.DO.Offset(offset))
}

func (n nftWorksPriceDo) Scopes(funcs ...func(gen.Dao) gen.Dao) INftWorksPriceDo {
	return n.withDO(n.DO.Scopes(funcs...))
}

func (n nftWorksPriceDo) Unscoped() INftWorksPriceDo {
	return n.withDO(n.DO.Unscoped())
}

func (n nftWorksPriceDo) Create(values ...*model.NftWorksPrice) error {
	if len(values) == 0 {
		return nil
	}
	return n.DO.Create(values)
}

func (n nftWorksPriceDo) CreateInBatches(values []*model.NftWorksPrice, batchSize int) error {
	return n.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (n nftWorksPriceDo) Save(values ...*model.NftWorksPrice) error {
	if len(values) == 0 {
		return nil
	}
	return n.DO.Save(values)
}

func (n nftWorksPriceDo) First() (*model.NftWorksPrice, error) {
	if result, err := n.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.NftWorksPrice), nil
	}
}

func (n nftWorksPriceDo) Take() (*model.NftWorksPrice, error) {
	if result, err := n.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.NftWorksPrice), nil
	}
}

func (n nftWorksPriceDo) Last() (*model.NftWorksPrice, error) {
	if result, err := n.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.NftWorksPrice), nil
	}
}

func (n nftWorksPriceDo) Find() ([]*model.NftWorksPrice, error) {
	result, err := n.DO.Find()
	return result.([]*model.NftWorksPrice), err
}

func (n nftWorksPriceDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.NftWorksPrice, err error) {
	buf := make([]*model.NftWorksPrice, 0, batchSize)
	err = n.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (n nftWorksPriceDo) FindInBatches(result *[]*model.NftWorksPrice, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return n.DO.FindInBatches(result, batchSize, fc)
}

func (n nftWorksPriceDo) Attrs(attrs ...field.AssignExpr) INftWorksPriceDo {
	return n.withDO(n.DO.Attrs(attrs...))
}

func (n nftWorksPriceDo) Assign(attrs ...field.AssignExpr) INftWorksPriceDo {
	return n.withDO(n.DO.Assign(attrs...))
}

func (n nftWorksPriceDo) Joins(fields ...field.RelationField) INftWorksPriceDo {
	for _, _f := range fields {
		n = *n.withDO(n.DO.Joins(_f))
	}
	return &n
}

func (n nftWorksPriceDo) Preload(fields ...field.RelationField) INftWorksPriceDo {
	for _, _f := range fields {
		n = *n.withDO(n.DO.Preload(_f))
	}
	return &n
}

func (n nftWorksPriceDo) FirstOrInit() (*model.NftWorksPrice, error) {
	if result, err := n.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.NftWorksPrice), nil
	}
}

func (n nftWorksPriceDo) FirstOrCreate() (*model.NftWorksPrice, error) {
	if result, err := n.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.NftWorksPrice), nil
	}
}

func (n nftWorksPriceDo) FindByPage(offset int, limit int) (result []*model.NftWorksPrice, count int64, err error) {
	result, err = n.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = n.Offset(-1).Limit(-1).Count()
	return
}

func (n nftWorksPriceDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = n.Count()
	if err != nil {
		return
	}

	err = n.Offset(offset).Limit(limit).Scan(result)
	return
}

func (n nftWorksPriceDo) Scan(result interface{}) (err error) {
	return n.DO.Scan(result)
}

func (n nftWorksPriceDo) Delete(models ...*model.NftWorksPrice) (result gen.ResultInfo, err error) {
	return n.DO.Delete(models)
}

func (n *nftWorksPriceDo) withDO(do gen.Dao) *nftWorksPriceDo {
	n.DO = *do.(*gen.DO)
	return n
}
