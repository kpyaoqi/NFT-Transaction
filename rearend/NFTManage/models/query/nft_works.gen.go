// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"yqnft/NFTManage/test/model"
)

func newNftWork(db *gorm.DB) nftWork {
	_nftWork := nftWork{}

	_nftWork.nftWorkDo.UseDB(db)
	_nftWork.nftWorkDo.UseModel(&model.NftWork{})

	tableName := _nftWork.nftWorkDo.TableName()
	_nftWork.ALL = field.NewAsterisk(tableName)
	_nftWork.ID = field.NewString(tableName, "id")
	_nftWork.TokenID = field.NewInt64(tableName, "tokenId")
	_nftWork.AuthorID = field.NewString(tableName, "authorId")
	_nftWork.CollectionID = field.NewString(tableName, "collectionId")
	_nftWork.DataPath = field.NewString(tableName, "dataPath")
	_nftWork.Name = field.NewString(tableName, "name")
	_nftWork.Type = field.NewInt64(tableName, "type")
	_nftWork.Link = field.NewString(tableName, "link")
	_nftWork.Details = field.NewString(tableName, "details")
	_nftWork.Price = field.NewFloat64(tableName, "price")
	_nftWork.Num = field.NewInt64(tableName, "num")
	_nftWork.Buyers = field.NewString(tableName, "buyers")
	_nftWork.InTime = field.NewTime(tableName, "inTime")
	_nftWork.OutTime = field.NewTime(tableName, "outTime")
	_nftWork.WaitingTime = field.NewTime(tableName, "waitingTime")
	_nftWork.ChainPlatCert = field.NewString(tableName, "chainPlatCert")
	_nftWork.State = field.NewInt64(tableName, "state")
	_nftWork.CreateTime = field.NewTime(tableName, "createTime")
	_nftWork.UpdateTime = field.NewTime(tableName, "updateTime")
	_nftWork.Bak1 = field.NewString(tableName, "bak1")
	_nftWork.Bak2 = field.NewString(tableName, "bak2")
	_nftWork.Bak3 = field.NewString(tableName, "bak3")

	_nftWork.fillFieldMap()

	return _nftWork
}

type nftWork struct {
	nftWorkDo nftWorkDo

	ALL           field.Asterisk
	ID            field.String // 唯一标识
	TokenID       field.Int64
	AuthorID      field.String  // 作者标识=用户标识
	CollectionID  field.String  // 合集标识
	DataPath      field.String  // 作品数据地址(图片Base64,上链)
	Name          field.String  // 作品名称
	Type          field.Int64   // 作品类型
	Link          field.String  // 自定义链接
	Details       field.String  // 作品简介(富文本)
	Price         field.Float64 // 作品价格(初始价格)
	Num           field.Int64   // 作者发行数量
	Buyers        field.String  // 作品购买者(用户标识,标识之间使用逗号隔开)
	InTime        field.Time    // 上架时间
	OutTime       field.Time    // 下架时间
	WaitingTime   field.Time    // 发布等待期,日期之后才可购买
	ChainPlatCert field.String  // 上架后,在不同链平台上链,认证后的数据-json
	State         field.Int64   // 作品状态(0:未上架,1:(已上架)售卖中,2:已售停,3:已下架,4:已删除)
	CreateTime    field.Time
	UpdateTime    field.Time
	Bak1          field.String
	Bak2          field.String
	Bak3          field.String

	fieldMap map[string]field.Expr
}

func (n nftWork) Table(newTableName string) *nftWork {
	n.nftWorkDo.UseTable(newTableName)
	return n.updateTableName(newTableName)
}

func (n nftWork) As(alias string) *nftWork {
	n.nftWorkDo.DO = *(n.nftWorkDo.As(alias).(*gen.DO))
	return n.updateTableName(alias)
}

func (n *nftWork) updateTableName(table string) *nftWork {
	n.ALL = field.NewAsterisk(table)
	n.ID = field.NewString(table, "id")
	n.TokenID = field.NewInt64(table, "tokenId")
	n.AuthorID = field.NewString(table, "authorId")
	n.CollectionID = field.NewString(table, "collectionId")
	n.DataPath = field.NewString(table, "dataPath")
	n.Name = field.NewString(table, "name")
	n.Type = field.NewInt64(table, "type")
	n.Link = field.NewString(table, "link")
	n.Details = field.NewString(table, "details")
	n.Price = field.NewFloat64(table, "price")
	n.Num = field.NewInt64(table, "num")
	n.Buyers = field.NewString(table, "buyers")
	n.InTime = field.NewTime(table, "inTime")
	n.OutTime = field.NewTime(table, "outTime")
	n.WaitingTime = field.NewTime(table, "waitingTime")
	n.ChainPlatCert = field.NewString(table, "chainPlatCert")
	n.State = field.NewInt64(table, "state")
	n.CreateTime = field.NewTime(table, "createTime")
	n.UpdateTime = field.NewTime(table, "updateTime")
	n.Bak1 = field.NewString(table, "bak1")
	n.Bak2 = field.NewString(table, "bak2")
	n.Bak3 = field.NewString(table, "bak3")

	n.fillFieldMap()

	return n
}

func (n *nftWork) WithContext(ctx context.Context) INftWorkDo { return n.nftWorkDo.WithContext(ctx) }

func (n nftWork) TableName() string { return n.nftWorkDo.TableName() }

func (n nftWork) Alias() string { return n.nftWorkDo.Alias() }

func (n *nftWork) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := n.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (n *nftWork) fillFieldMap() {
	n.fieldMap = make(map[string]field.Expr, 22)
	n.fieldMap["id"] = n.ID
	n.fieldMap["tokenId"] = n.TokenID
	n.fieldMap["authorId"] = n.AuthorID
	n.fieldMap["collectionId"] = n.CollectionID
	n.fieldMap["dataPath"] = n.DataPath
	n.fieldMap["name"] = n.Name
	n.fieldMap["type"] = n.Type
	n.fieldMap["link"] = n.Link
	n.fieldMap["details"] = n.Details
	n.fieldMap["price"] = n.Price
	n.fieldMap["num"] = n.Num
	n.fieldMap["buyers"] = n.Buyers
	n.fieldMap["inTime"] = n.InTime
	n.fieldMap["outTime"] = n.OutTime
	n.fieldMap["waitingTime"] = n.WaitingTime
	n.fieldMap["chainPlatCert"] = n.ChainPlatCert
	n.fieldMap["state"] = n.State
	n.fieldMap["createTime"] = n.CreateTime
	n.fieldMap["updateTime"] = n.UpdateTime
	n.fieldMap["bak1"] = n.Bak1
	n.fieldMap["bak2"] = n.Bak2
	n.fieldMap["bak3"] = n.Bak3
}

func (n nftWork) clone(db *gorm.DB) nftWork {
	n.nftWorkDo.ReplaceDB(db)
	return n
}

type nftWorkDo struct{ gen.DO }

type INftWorkDo interface {
	gen.SubQuery
	Debug() INftWorkDo
	WithContext(ctx context.Context) INftWorkDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	As(alias string) gen.Dao
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) INftWorkDo
	Not(conds ...gen.Condition) INftWorkDo
	Or(conds ...gen.Condition) INftWorkDo
	Select(conds ...field.Expr) INftWorkDo
	Where(conds ...gen.Condition) INftWorkDo
	Order(conds ...field.Expr) INftWorkDo
	Distinct(cols ...field.Expr) INftWorkDo
	Omit(cols ...field.Expr) INftWorkDo
	Join(table schema.Tabler, on ...field.Expr) INftWorkDo
	LeftJoin(table schema.Tabler, on ...field.Expr) INftWorkDo
	RightJoin(table schema.Tabler, on ...field.Expr) INftWorkDo
	Group(cols ...field.Expr) INftWorkDo
	Having(conds ...gen.Condition) INftWorkDo
	Limit(limit int) INftWorkDo
	Offset(offset int) INftWorkDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) INftWorkDo
	Unscoped() INftWorkDo
	Create(values ...*model.NftWork) error
	CreateInBatches(values []*model.NftWork, batchSize int) error
	Save(values ...*model.NftWork) error
	First() (*model.NftWork, error)
	Take() (*model.NftWork, error)
	Last() (*model.NftWork, error)
	Find() ([]*model.NftWork, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.NftWork, err error)
	FindInBatches(result *[]*model.NftWork, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.NftWork) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) INftWorkDo
	Assign(attrs ...field.AssignExpr) INftWorkDo
	Joins(fields ...field.RelationField) INftWorkDo
	Preload(fields ...field.RelationField) INftWorkDo
	FirstOrInit() (*model.NftWork, error)
	FirstOrCreate() (*model.NftWork, error)
	FindByPage(offset int, limit int) (result []*model.NftWork, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) INftWorkDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (n nftWorkDo) Debug() INftWorkDo {
	return n.withDO(n.DO.Debug())
}

func (n nftWorkDo) WithContext(ctx context.Context) INftWorkDo {
	return n.withDO(n.DO.WithContext(ctx))
}

func (n nftWorkDo) ReadDB() INftWorkDo {
	return n.Clauses(dbresolver.Read)
}

func (n nftWorkDo) WriteDB() INftWorkDo {
	return n.Clauses(dbresolver.Write)
}

func (n nftWorkDo) Clauses(conds ...clause.Expression) INftWorkDo {
	return n.withDO(n.DO.Clauses(conds...))
}

func (n nftWorkDo) Returning(value interface{}, columns ...string) INftWorkDo {
	return n.withDO(n.DO.Returning(value, columns...))
}

func (n nftWorkDo) Not(conds ...gen.Condition) INftWorkDo {
	return n.withDO(n.DO.Not(conds...))
}

func (n nftWorkDo) Or(conds ...gen.Condition) INftWorkDo {
	return n.withDO(n.DO.Or(conds...))
}

func (n nftWorkDo) Select(conds ...field.Expr) INftWorkDo {
	return n.withDO(n.DO.Select(conds...))
}

func (n nftWorkDo) Where(conds ...gen.Condition) INftWorkDo {
	return n.withDO(n.DO.Where(conds...))
}

func (n nftWorkDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) INftWorkDo {
	return n.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (n nftWorkDo) Order(conds ...field.Expr) INftWorkDo {
	return n.withDO(n.DO.Order(conds...))
}

func (n nftWorkDo) Distinct(cols ...field.Expr) INftWorkDo {
	return n.withDO(n.DO.Distinct(cols...))
}

func (n nftWorkDo) Omit(cols ...field.Expr) INftWorkDo {
	return n.withDO(n.DO.Omit(cols...))
}

func (n nftWorkDo) Join(table schema.Tabler, on ...field.Expr) INftWorkDo {
	return n.withDO(n.DO.Join(table, on...))
}

func (n nftWorkDo) LeftJoin(table schema.Tabler, on ...field.Expr) INftWorkDo {
	return n.withDO(n.DO.LeftJoin(table, on...))
}

func (n nftWorkDo) RightJoin(table schema.Tabler, on ...field.Expr) INftWorkDo {
	return n.withDO(n.DO.RightJoin(table, on...))
}

func (n nftWorkDo) Group(cols ...field.Expr) INftWorkDo {
	return n.withDO(n.DO.Group(cols...))
}

func (n nftWorkDo) Having(conds ...gen.Condition) INftWorkDo {
	return n.withDO(n.DO.Having(conds...))
}

func (n nftWorkDo) Limit(limit int) INftWorkDo {
	return n.withDO(n.DO.Limit(limit))
}

func (n nftWorkDo) Offset(offset int) INftWorkDo {
	return n.withDO(n.DO.Offset(offset))
}

func (n nftWorkDo) Scopes(funcs ...func(gen.Dao) gen.Dao) INftWorkDo {
	return n.withDO(n.DO.Scopes(funcs...))
}

func (n nftWorkDo) Unscoped() INftWorkDo {
	return n.withDO(n.DO.Unscoped())
}

func (n nftWorkDo) Create(values ...*model.NftWork) error {
	if len(values) == 0 {
		return nil
	}
	return n.DO.Create(values)
}

func (n nftWorkDo) CreateInBatches(values []*model.NftWork, batchSize int) error {
	return n.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (n nftWorkDo) Save(values ...*model.NftWork) error {
	if len(values) == 0 {
		return nil
	}
	return n.DO.Save(values)
}

func (n nftWorkDo) First() (*model.NftWork, error) {
	if result, err := n.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.NftWork), nil
	}
}

func (n nftWorkDo) Take() (*model.NftWork, error) {
	if result, err := n.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.NftWork), nil
	}
}

func (n nftWorkDo) Last() (*model.NftWork, error) {
	if result, err := n.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.NftWork), nil
	}
}

func (n nftWorkDo) Find() ([]*model.NftWork, error) {
	result, err := n.DO.Find()
	return result.([]*model.NftWork), err
}

func (n nftWorkDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.NftWork, err error) {
	buf := make([]*model.NftWork, 0, batchSize)
	err = n.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (n nftWorkDo) FindInBatches(result *[]*model.NftWork, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return n.DO.FindInBatches(result, batchSize, fc)
}

func (n nftWorkDo) Attrs(attrs ...field.AssignExpr) INftWorkDo {
	return n.withDO(n.DO.Attrs(attrs...))
}

func (n nftWorkDo) Assign(attrs ...field.AssignExpr) INftWorkDo {
	return n.withDO(n.DO.Assign(attrs...))
}

func (n nftWorkDo) Joins(fields ...field.RelationField) INftWorkDo {
	for _, _f := range fields {
		n = *n.withDO(n.DO.Joins(_f))
	}
	return &n
}

func (n nftWorkDo) Preload(fields ...field.RelationField) INftWorkDo {
	for _, _f := range fields {
		n = *n.withDO(n.DO.Preload(_f))
	}
	return &n
}

func (n nftWorkDo) FirstOrInit() (*model.NftWork, error) {
	if result, err := n.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.NftWork), nil
	}
}

func (n nftWorkDo) FirstOrCreate() (*model.NftWork, error) {
	if result, err := n.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.NftWork), nil
	}
}

func (n nftWorkDo) FindByPage(offset int, limit int) (result []*model.NftWork, count int64, err error) {
	result, err = n.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = n.Offset(-1).Limit(-1).Count()
	return
}

func (n nftWorkDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = n.Count()
	if err != nil {
		return
	}

	err = n.Offset(offset).Limit(limit).Scan(result)
	return
}

func (n nftWorkDo) Scan(result interface{}) (err error) {
	return n.DO.Scan(result)
}

func (n nftWorkDo) Delete(models ...*model.NftWork) (result gen.ResultInfo, err error) {
	return n.DO.Delete(models)
}

func (n *nftWorkDo) withDO(do gen.Dao) *nftWorkDo {
	n.DO = *do.(*gen.DO)
	return n
}
