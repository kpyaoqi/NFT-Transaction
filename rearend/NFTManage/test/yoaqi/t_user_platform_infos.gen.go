// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package yoaqi

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"yqnft/NFTManage/test/model"
)

func newTUserPlatformInfo(db *gorm.DB) tUserPlatformInfo {
	_tUserPlatformInfo := tUserPlatformInfo{}

	_tUserPlatformInfo.tUserPlatformInfoDo.UseDB(db)
	_tUserPlatformInfo.tUserPlatformInfoDo.UseModel(&model.TUserPlatformInfo{})

	tableName := _tUserPlatformInfo.tUserPlatformInfoDo.TableName()
	_tUserPlatformInfo.ALL = field.NewAsterisk(tableName)
	_tUserPlatformInfo.ID = field.NewString(tableName, "id")
	_tUserPlatformInfo.OpenID = field.NewString(tableName, "openId")
	_tUserPlatformInfo.DeviceType = field.NewInt64(tableName, "deviceType")
	_tUserPlatformInfo.SiteID = field.NewString(tableName, "siteId")
	_tUserPlatformInfo.UserID = field.NewString(tableName, "userId")
	_tUserPlatformInfo.Bak1 = field.NewString(tableName, "bak1")
	_tUserPlatformInfo.Bak2 = field.NewString(tableName, "bak2")
	_tUserPlatformInfo.Bak3 = field.NewString(tableName, "bak3")
	_tUserPlatformInfo.Bak4 = field.NewString(tableName, "bak4")

	_tUserPlatformInfo.fillFieldMap()

	return _tUserPlatformInfo
}

type tUserPlatformInfo struct {
	tUserPlatformInfoDo tUserPlatformInfoDo

	ALL        field.Asterisk
	ID         field.String // 主键id
	OpenID     field.String // 公众号openId,企业号userId,小程序openId,APP推送deviceToken
	DeviceType field.Int64  // 设备/应用类型：1公众号2小程序3企业号4APP IOS消息推送5APP安卓消息推送6web
	SiteID     field.String // 所属站点ID
	UserID     field.String // t_user表中ID
	Bak1       field.String
	Bak2       field.String
	Bak3       field.String
	Bak4       field.String

	fieldMap map[string]field.Expr
}

func (t tUserPlatformInfo) Table(newTableName string) *tUserPlatformInfo {
	t.tUserPlatformInfoDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t tUserPlatformInfo) As(alias string) *tUserPlatformInfo {
	t.tUserPlatformInfoDo.DO = *(t.tUserPlatformInfoDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *tUserPlatformInfo) updateTableName(table string) *tUserPlatformInfo {
	t.ALL = field.NewAsterisk(table)
	t.ID = field.NewString(table, "id")
	t.OpenID = field.NewString(table, "openId")
	t.DeviceType = field.NewInt64(table, "deviceType")
	t.SiteID = field.NewString(table, "siteId")
	t.UserID = field.NewString(table, "userId")
	t.Bak1 = field.NewString(table, "bak1")
	t.Bak2 = field.NewString(table, "bak2")
	t.Bak3 = field.NewString(table, "bak3")
	t.Bak4 = field.NewString(table, "bak4")

	t.fillFieldMap()

	return t
}

func (t *tUserPlatformInfo) WithContext(ctx context.Context) ITUserPlatformInfoDo {
	return t.tUserPlatformInfoDo.WithContext(ctx)
}

func (t tUserPlatformInfo) TableName() string { return t.tUserPlatformInfoDo.TableName() }

func (t tUserPlatformInfo) Alias() string { return t.tUserPlatformInfoDo.Alias() }

func (t *tUserPlatformInfo) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *tUserPlatformInfo) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 9)
	t.fieldMap["id"] = t.ID
	t.fieldMap["openId"] = t.OpenID
	t.fieldMap["deviceType"] = t.DeviceType
	t.fieldMap["siteId"] = t.SiteID
	t.fieldMap["userId"] = t.UserID
	t.fieldMap["bak1"] = t.Bak1
	t.fieldMap["bak2"] = t.Bak2
	t.fieldMap["bak3"] = t.Bak3
	t.fieldMap["bak4"] = t.Bak4
}

func (t tUserPlatformInfo) clone(db *gorm.DB) tUserPlatformInfo {
	t.tUserPlatformInfoDo.ReplaceDB(db)
	return t
}

type tUserPlatformInfoDo struct{ gen.DO }

type ITUserPlatformInfoDo interface {
	gen.SubQuery
	Debug() ITUserPlatformInfoDo
	WithContext(ctx context.Context) ITUserPlatformInfoDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	As(alias string) gen.Dao
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITUserPlatformInfoDo
	Not(conds ...gen.Condition) ITUserPlatformInfoDo
	Or(conds ...gen.Condition) ITUserPlatformInfoDo
	Select(conds ...field.Expr) ITUserPlatformInfoDo
	Where(conds ...gen.Condition) ITUserPlatformInfoDo
	Order(conds ...field.Expr) ITUserPlatformInfoDo
	Distinct(cols ...field.Expr) ITUserPlatformInfoDo
	Omit(cols ...field.Expr) ITUserPlatformInfoDo
	Join(table schema.Tabler, on ...field.Expr) ITUserPlatformInfoDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITUserPlatformInfoDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITUserPlatformInfoDo
	Group(cols ...field.Expr) ITUserPlatformInfoDo
	Having(conds ...gen.Condition) ITUserPlatformInfoDo
	Limit(limit int) ITUserPlatformInfoDo
	Offset(offset int) ITUserPlatformInfoDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITUserPlatformInfoDo
	Unscoped() ITUserPlatformInfoDo
	Create(values ...*model.TUserPlatformInfo) error
	CreateInBatches(values []*model.TUserPlatformInfo, batchSize int) error
	Save(values ...*model.TUserPlatformInfo) error
	First() (*model.TUserPlatformInfo, error)
	Take() (*model.TUserPlatformInfo, error)
	Last() (*model.TUserPlatformInfo, error)
	Find() ([]*model.TUserPlatformInfo, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TUserPlatformInfo, err error)
	FindInBatches(result *[]*model.TUserPlatformInfo, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.TUserPlatformInfo) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITUserPlatformInfoDo
	Assign(attrs ...field.AssignExpr) ITUserPlatformInfoDo
	Joins(fields ...field.RelationField) ITUserPlatformInfoDo
	Preload(fields ...field.RelationField) ITUserPlatformInfoDo
	FirstOrInit() (*model.TUserPlatformInfo, error)
	FirstOrCreate() (*model.TUserPlatformInfo, error)
	FindByPage(offset int, limit int) (result []*model.TUserPlatformInfo, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITUserPlatformInfoDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t tUserPlatformInfoDo) Debug() ITUserPlatformInfoDo {
	return t.withDO(t.DO.Debug())
}

func (t tUserPlatformInfoDo) WithContext(ctx context.Context) ITUserPlatformInfoDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t tUserPlatformInfoDo) ReadDB() ITUserPlatformInfoDo {
	return t.Clauses(dbresolver.Read)
}

func (t tUserPlatformInfoDo) WriteDB() ITUserPlatformInfoDo {
	return t.Clauses(dbresolver.Write)
}

func (t tUserPlatformInfoDo) Clauses(conds ...clause.Expression) ITUserPlatformInfoDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t tUserPlatformInfoDo) Returning(value interface{}, columns ...string) ITUserPlatformInfoDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t tUserPlatformInfoDo) Not(conds ...gen.Condition) ITUserPlatformInfoDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t tUserPlatformInfoDo) Or(conds ...gen.Condition) ITUserPlatformInfoDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t tUserPlatformInfoDo) Select(conds ...field.Expr) ITUserPlatformInfoDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t tUserPlatformInfoDo) Where(conds ...gen.Condition) ITUserPlatformInfoDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t tUserPlatformInfoDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) ITUserPlatformInfoDo {
	return t.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (t tUserPlatformInfoDo) Order(conds ...field.Expr) ITUserPlatformInfoDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t tUserPlatformInfoDo) Distinct(cols ...field.Expr) ITUserPlatformInfoDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t tUserPlatformInfoDo) Omit(cols ...field.Expr) ITUserPlatformInfoDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t tUserPlatformInfoDo) Join(table schema.Tabler, on ...field.Expr) ITUserPlatformInfoDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t tUserPlatformInfoDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITUserPlatformInfoDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t tUserPlatformInfoDo) RightJoin(table schema.Tabler, on ...field.Expr) ITUserPlatformInfoDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t tUserPlatformInfoDo) Group(cols ...field.Expr) ITUserPlatformInfoDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t tUserPlatformInfoDo) Having(conds ...gen.Condition) ITUserPlatformInfoDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t tUserPlatformInfoDo) Limit(limit int) ITUserPlatformInfoDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t tUserPlatformInfoDo) Offset(offset int) ITUserPlatformInfoDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t tUserPlatformInfoDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITUserPlatformInfoDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t tUserPlatformInfoDo) Unscoped() ITUserPlatformInfoDo {
	return t.withDO(t.DO.Unscoped())
}

func (t tUserPlatformInfoDo) Create(values ...*model.TUserPlatformInfo) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t tUserPlatformInfoDo) CreateInBatches(values []*model.TUserPlatformInfo, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t tUserPlatformInfoDo) Save(values ...*model.TUserPlatformInfo) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t tUserPlatformInfoDo) First() (*model.TUserPlatformInfo, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TUserPlatformInfo), nil
	}
}

func (t tUserPlatformInfoDo) Take() (*model.TUserPlatformInfo, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TUserPlatformInfo), nil
	}
}

func (t tUserPlatformInfoDo) Last() (*model.TUserPlatformInfo, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TUserPlatformInfo), nil
	}
}

func (t tUserPlatformInfoDo) Find() ([]*model.TUserPlatformInfo, error) {
	result, err := t.DO.Find()
	return result.([]*model.TUserPlatformInfo), err
}

func (t tUserPlatformInfoDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TUserPlatformInfo, err error) {
	buf := make([]*model.TUserPlatformInfo, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t tUserPlatformInfoDo) FindInBatches(result *[]*model.TUserPlatformInfo, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t tUserPlatformInfoDo) Attrs(attrs ...field.AssignExpr) ITUserPlatformInfoDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t tUserPlatformInfoDo) Assign(attrs ...field.AssignExpr) ITUserPlatformInfoDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t tUserPlatformInfoDo) Joins(fields ...field.RelationField) ITUserPlatformInfoDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t tUserPlatformInfoDo) Preload(fields ...field.RelationField) ITUserPlatformInfoDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t tUserPlatformInfoDo) FirstOrInit() (*model.TUserPlatformInfo, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TUserPlatformInfo), nil
	}
}

func (t tUserPlatformInfoDo) FirstOrCreate() (*model.TUserPlatformInfo, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TUserPlatformInfo), nil
	}
}

func (t tUserPlatformInfoDo) FindByPage(offset int, limit int) (result []*model.TUserPlatformInfo, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t tUserPlatformInfoDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t tUserPlatformInfoDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t tUserPlatformInfoDo) Delete(models ...*model.TUserPlatformInfo) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *tUserPlatformInfoDo) withDO(do gen.Dao) *tUserPlatformInfoDo {
	t.DO = *do.(*gen.DO)
	return t
}
