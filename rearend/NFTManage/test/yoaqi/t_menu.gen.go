// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package yoaqi

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"yqnft/NFTManage/test/model"
)

func newTMenu(db *gorm.DB) tMenu {
	_tMenu := tMenu{}

	_tMenu.tMenuDo.UseDB(db)
	_tMenu.tMenuDo.UseModel(&model.TMenu{})

	tableName := _tMenu.tMenuDo.TableName()
	_tMenu.ALL = field.NewAsterisk(tableName)
	_tMenu.ID = field.NewString(tableName, "id")
	_tMenu.Name = field.NewString(tableName, "name")
	_tMenu.Comcode = field.NewString(tableName, "comcode")
	_tMenu.Title = field.NewString(tableName, "title")
	_tMenu.Pid = field.NewString(tableName, "pid")
	_tMenu.Remark = field.NewString(tableName, "remark")
	_tMenu.Pageurl = field.NewString(tableName, "pageurl")
	_tMenu.Code = field.NewString(tableName, "code")
	_tMenu.MenuType = field.NewInt64(tableName, "menuType")
	_tMenu.Path = field.NewString(tableName, "path")
	_tMenu.KeepAlive = field.NewInt64(tableName, "keepAlive")
	_tMenu.Component = field.NewString(tableName, "component")
	_tMenu.Permission = field.NewString(tableName, "permission")
	_tMenu.Redirect = field.NewString(tableName, "redirect")
	_tMenu.Icon = field.NewString(tableName, "icon")
	_tMenu.URL = field.NewString(tableName, "url")
	_tMenu.Target = field.NewString(tableName, "target")
	_tMenu.CreateTime = field.NewTime(tableName, "createTime")
	_tMenu.CreateUserID = field.NewString(tableName, "createUserId")
	_tMenu.UpdateTime = field.NewTime(tableName, "updateTime")
	_tMenu.UpdateUserID = field.NewString(tableName, "updateUserId")
	_tMenu.Sortno = field.NewInt64(tableName, "sortno")
	_tMenu.Active = field.NewInt64(tableName, "active")
	_tMenu.Bak1 = field.NewString(tableName, "bak1")
	_tMenu.Bak2 = field.NewString(tableName, "bak2")
	_tMenu.Bak3 = field.NewString(tableName, "bak3")
	_tMenu.Bak4 = field.NewString(tableName, "bak4")
	_tMenu.Bak5 = field.NewString(tableName, "bak5")

	_tMenu.fillFieldMap()

	return _tMenu
}

type tMenu struct {
	tMenuDo tMenuDo

	ALL          field.Asterisk
	ID           field.String
	Name         field.String // 菜单名称
	Comcode      field.String // 代码
	Title        field.String // vue使用 meta.title
	Pid          field.String
	Remark       field.String // 备注
	Pageurl      field.String
	Code         field.String // 权限显示key,功能，用于按钮显示判断
	MenuType     field.Int64  // 0.功能按钮,1.导航菜单
	Path         field.String // vue路由地址
	KeepAlive    field.Int64  // vue组件使用
	Component    field.String // vue组件使用
	Permission   field.String // vue组件使用
	Redirect     field.String // vue组件使用
	Icon         field.String
	URL          field.String // 站外url
	Target       field.String // 窗口标识
	CreateTime   field.Time
	CreateUserID field.String
	UpdateTime   field.Time
	UpdateUserID field.String
	Sortno       field.Int64 // 排序,查询时倒叙排列
	Active       field.Int64 // 是否有效(0否,1是)
	Bak1         field.String
	Bak2         field.String
	Bak3         field.String
	Bak4         field.String
	Bak5         field.String

	fieldMap map[string]field.Expr
}

func (t tMenu) Table(newTableName string) *tMenu {
	t.tMenuDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t tMenu) As(alias string) *tMenu {
	t.tMenuDo.DO = *(t.tMenuDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *tMenu) updateTableName(table string) *tMenu {
	t.ALL = field.NewAsterisk(table)
	t.ID = field.NewString(table, "id")
	t.Name = field.NewString(table, "name")
	t.Comcode = field.NewString(table, "comcode")
	t.Title = field.NewString(table, "title")
	t.Pid = field.NewString(table, "pid")
	t.Remark = field.NewString(table, "remark")
	t.Pageurl = field.NewString(table, "pageurl")
	t.Code = field.NewString(table, "code")
	t.MenuType = field.NewInt64(table, "menuType")
	t.Path = field.NewString(table, "path")
	t.KeepAlive = field.NewInt64(table, "keepAlive")
	t.Component = field.NewString(table, "component")
	t.Permission = field.NewString(table, "permission")
	t.Redirect = field.NewString(table, "redirect")
	t.Icon = field.NewString(table, "icon")
	t.URL = field.NewString(table, "url")
	t.Target = field.NewString(table, "target")
	t.CreateTime = field.NewTime(table, "createTime")
	t.CreateUserID = field.NewString(table, "createUserId")
	t.UpdateTime = field.NewTime(table, "updateTime")
	t.UpdateUserID = field.NewString(table, "updateUserId")
	t.Sortno = field.NewInt64(table, "sortno")
	t.Active = field.NewInt64(table, "active")
	t.Bak1 = field.NewString(table, "bak1")
	t.Bak2 = field.NewString(table, "bak2")
	t.Bak3 = field.NewString(table, "bak3")
	t.Bak4 = field.NewString(table, "bak4")
	t.Bak5 = field.NewString(table, "bak5")

	t.fillFieldMap()

	return t
}

func (t *tMenu) WithContext(ctx context.Context) ITMenuDo { return t.tMenuDo.WithContext(ctx) }

func (t tMenu) TableName() string { return t.tMenuDo.TableName() }

func (t tMenu) Alias() string { return t.tMenuDo.Alias() }

func (t *tMenu) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *tMenu) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 28)
	t.fieldMap["id"] = t.ID
	t.fieldMap["name"] = t.Name
	t.fieldMap["comcode"] = t.Comcode
	t.fieldMap["title"] = t.Title
	t.fieldMap["pid"] = t.Pid
	t.fieldMap["remark"] = t.Remark
	t.fieldMap["pageurl"] = t.Pageurl
	t.fieldMap["code"] = t.Code
	t.fieldMap["menuType"] = t.MenuType
	t.fieldMap["path"] = t.Path
	t.fieldMap["keepAlive"] = t.KeepAlive
	t.fieldMap["component"] = t.Component
	t.fieldMap["permission"] = t.Permission
	t.fieldMap["redirect"] = t.Redirect
	t.fieldMap["icon"] = t.Icon
	t.fieldMap["url"] = t.URL
	t.fieldMap["target"] = t.Target
	t.fieldMap["createTime"] = t.CreateTime
	t.fieldMap["createUserId"] = t.CreateUserID
	t.fieldMap["updateTime"] = t.UpdateTime
	t.fieldMap["updateUserId"] = t.UpdateUserID
	t.fieldMap["sortno"] = t.Sortno
	t.fieldMap["active"] = t.Active
	t.fieldMap["bak1"] = t.Bak1
	t.fieldMap["bak2"] = t.Bak2
	t.fieldMap["bak3"] = t.Bak3
	t.fieldMap["bak4"] = t.Bak4
	t.fieldMap["bak5"] = t.Bak5
}

func (t tMenu) clone(db *gorm.DB) tMenu {
	t.tMenuDo.ReplaceDB(db)
	return t
}

type tMenuDo struct{ gen.DO }

type ITMenuDo interface {
	gen.SubQuery
	Debug() ITMenuDo
	WithContext(ctx context.Context) ITMenuDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	As(alias string) gen.Dao
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITMenuDo
	Not(conds ...gen.Condition) ITMenuDo
	Or(conds ...gen.Condition) ITMenuDo
	Select(conds ...field.Expr) ITMenuDo
	Where(conds ...gen.Condition) ITMenuDo
	Order(conds ...field.Expr) ITMenuDo
	Distinct(cols ...field.Expr) ITMenuDo
	Omit(cols ...field.Expr) ITMenuDo
	Join(table schema.Tabler, on ...field.Expr) ITMenuDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITMenuDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITMenuDo
	Group(cols ...field.Expr) ITMenuDo
	Having(conds ...gen.Condition) ITMenuDo
	Limit(limit int) ITMenuDo
	Offset(offset int) ITMenuDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITMenuDo
	Unscoped() ITMenuDo
	Create(values ...*model.TMenu) error
	CreateInBatches(values []*model.TMenu, batchSize int) error
	Save(values ...*model.TMenu) error
	First() (*model.TMenu, error)
	Take() (*model.TMenu, error)
	Last() (*model.TMenu, error)
	Find() ([]*model.TMenu, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TMenu, err error)
	FindInBatches(result *[]*model.TMenu, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.TMenu) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITMenuDo
	Assign(attrs ...field.AssignExpr) ITMenuDo
	Joins(fields ...field.RelationField) ITMenuDo
	Preload(fields ...field.RelationField) ITMenuDo
	FirstOrInit() (*model.TMenu, error)
	FirstOrCreate() (*model.TMenu, error)
	FindByPage(offset int, limit int) (result []*model.TMenu, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITMenuDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t tMenuDo) Debug() ITMenuDo {
	return t.withDO(t.DO.Debug())
}

func (t tMenuDo) WithContext(ctx context.Context) ITMenuDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t tMenuDo) ReadDB() ITMenuDo {
	return t.Clauses(dbresolver.Read)
}

func (t tMenuDo) WriteDB() ITMenuDo {
	return t.Clauses(dbresolver.Write)
}

func (t tMenuDo) Clauses(conds ...clause.Expression) ITMenuDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t tMenuDo) Returning(value interface{}, columns ...string) ITMenuDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t tMenuDo) Not(conds ...gen.Condition) ITMenuDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t tMenuDo) Or(conds ...gen.Condition) ITMenuDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t tMenuDo) Select(conds ...field.Expr) ITMenuDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t tMenuDo) Where(conds ...gen.Condition) ITMenuDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t tMenuDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) ITMenuDo {
	return t.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (t tMenuDo) Order(conds ...field.Expr) ITMenuDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t tMenuDo) Distinct(cols ...field.Expr) ITMenuDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t tMenuDo) Omit(cols ...field.Expr) ITMenuDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t tMenuDo) Join(table schema.Tabler, on ...field.Expr) ITMenuDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t tMenuDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITMenuDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t tMenuDo) RightJoin(table schema.Tabler, on ...field.Expr) ITMenuDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t tMenuDo) Group(cols ...field.Expr) ITMenuDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t tMenuDo) Having(conds ...gen.Condition) ITMenuDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t tMenuDo) Limit(limit int) ITMenuDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t tMenuDo) Offset(offset int) ITMenuDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t tMenuDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITMenuDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t tMenuDo) Unscoped() ITMenuDo {
	return t.withDO(t.DO.Unscoped())
}

func (t tMenuDo) Create(values ...*model.TMenu) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t tMenuDo) CreateInBatches(values []*model.TMenu, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t tMenuDo) Save(values ...*model.TMenu) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t tMenuDo) First() (*model.TMenu, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TMenu), nil
	}
}

func (t tMenuDo) Take() (*model.TMenu, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TMenu), nil
	}
}

func (t tMenuDo) Last() (*model.TMenu, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TMenu), nil
	}
}

func (t tMenuDo) Find() ([]*model.TMenu, error) {
	result, err := t.DO.Find()
	return result.([]*model.TMenu), err
}

func (t tMenuDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TMenu, err error) {
	buf := make([]*model.TMenu, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t tMenuDo) FindInBatches(result *[]*model.TMenu, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t tMenuDo) Attrs(attrs ...field.AssignExpr) ITMenuDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t tMenuDo) Assign(attrs ...field.AssignExpr) ITMenuDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t tMenuDo) Joins(fields ...field.RelationField) ITMenuDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t tMenuDo) Preload(fields ...field.RelationField) ITMenuDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t tMenuDo) FirstOrInit() (*model.TMenu, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TMenu), nil
	}
}

func (t tMenuDo) FirstOrCreate() (*model.TMenu, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TMenu), nil
	}
}

func (t tMenuDo) FindByPage(offset int, limit int) (result []*model.TMenu, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t tMenuDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t tMenuDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t tMenuDo) Delete(models ...*model.TMenu) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *tMenuDo) withDO(do gen.Dao) *tMenuDo {
	t.DO = *do.(*gen.DO)
	return t
}
