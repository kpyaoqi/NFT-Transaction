// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package yoaqi

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"yqnft/NFTManage/test/model"
)

func newNftCollection(db *gorm.DB) nftCollection {
	_nftCollection := nftCollection{}

	_nftCollection.nftCollectionDo.UseDB(db)
	_nftCollection.nftCollectionDo.UseModel(&model.NftCollection{})

	tableName := _nftCollection.nftCollectionDo.TableName()
	_nftCollection.ALL = field.NewAsterisk(tableName)
	_nftCollection.ID = field.NewString(tableName, "id")
	_nftCollection.UserID = field.NewString(tableName, "userId")
	_nftCollection.LogoPath = field.NewString(tableName, "logoPath")
	_nftCollection.CoverPath = field.NewString(tableName, "coverPath")
	_nftCollection.BannerPath = field.NewString(tableName, "bannerPath")
	_nftCollection.Name = field.NewString(tableName, "name")
	_nftCollection.Symbol = field.NewString(tableName, "symbol")
	_nftCollection.Link = field.NewString(tableName, "link")
	_nftCollection.Details = field.NewString(tableName, "details")
	_nftCollection.Type = field.NewInt64(tableName, "type")
	_nftCollection.Royalties = field.NewString(tableName, "royalties")
	_nftCollection.ChainPlatCert = field.NewString(tableName, "chainPlatCert")
	_nftCollection.IsIn = field.NewInt64(tableName, "isIn")
	_nftCollection.InTime = field.NewTime(tableName, "inTime")
	_nftCollection.OutTime = field.NewTime(tableName, "outTime")
	_nftCollection.IsCert = field.NewInt64(tableName, "isCert")
	_nftCollection.CreateTime = field.NewTime(tableName, "createTime")
	_nftCollection.UpdateTime = field.NewTime(tableName, "updateTime")
	_nftCollection.Fire = field.NewInt64(tableName, "fire")
	_nftCollection.SumPrice = field.NewFloat64(tableName, "sumPrice")
	_nftCollection.Lowprice = field.NewFloat64(tableName, "lowprice")
	_nftCollection.Buyersnum = field.NewInt64(tableName, "buyersnum")
	_nftCollection.Weekchange = field.NewFloat64(tableName, "weekchange")
	_nftCollection.Daychange = field.NewFloat64(tableName, "daychange")

	_nftCollection.fillFieldMap()

	return _nftCollection
}

type nftCollection struct {
	nftCollectionDo nftCollectionDo

	ALL           field.Asterisk
	ID            field.String // 唯一标识
	UserID        field.String // 用户标识
	LogoPath      field.String // logo图地址
	CoverPath     field.String // 合集封面地址
	BannerPath    field.String // banner图地址
	Name          field.String // 合集名称
	Symbol        field.String // NFT Symbol
	Link          field.String // 自定义链接
	Details       field.String // 合集简介
	Type          field.Int64  // 合集类别
	Royalties     field.String // 合集版税，百分比
	ChainPlatCert field.String // 上架后,在不同链平台上链,认证后的数据-json
	IsIn          field.Int64  // 是否上架 0:否,1:是
	InTime        field.Time   // 上架时间
	OutTime       field.Time   // 下架时间
	IsCert        field.Int64  // 是否平台认证,0:否,1是
	CreateTime    field.Time
	UpdateTime    field.Time
	Fire          field.Int64   // 热度值
	SumPrice      field.Float64 // 交易总额
	Lowprice      field.Float64 // 地板价
	Buyersnum     field.Int64   // 拥有者数量
	Weekchange    field.Float64 // 7天涨跌幅
	Daychange     field.Float64 // 1天涨跌幅

	fieldMap map[string]field.Expr
}

func (n nftCollection) Table(newTableName string) *nftCollection {
	n.nftCollectionDo.UseTable(newTableName)
	return n.updateTableName(newTableName)
}

func (n nftCollection) As(alias string) *nftCollection {
	n.nftCollectionDo.DO = *(n.nftCollectionDo.As(alias).(*gen.DO))
	return n.updateTableName(alias)
}

func (n *nftCollection) updateTableName(table string) *nftCollection {
	n.ALL = field.NewAsterisk(table)
	n.ID = field.NewString(table, "id")
	n.UserID = field.NewString(table, "userId")
	n.LogoPath = field.NewString(table, "logoPath")
	n.CoverPath = field.NewString(table, "coverPath")
	n.BannerPath = field.NewString(table, "bannerPath")
	n.Name = field.NewString(table, "name")
	n.Symbol = field.NewString(table, "symbol")
	n.Link = field.NewString(table, "link")
	n.Details = field.NewString(table, "details")
	n.Type = field.NewInt64(table, "type")
	n.Royalties = field.NewString(table, "royalties")
	n.ChainPlatCert = field.NewString(table, "chainPlatCert")
	n.IsIn = field.NewInt64(table, "isIn")
	n.InTime = field.NewTime(table, "inTime")
	n.OutTime = field.NewTime(table, "outTime")
	n.IsCert = field.NewInt64(table, "isCert")
	n.CreateTime = field.NewTime(table, "createTime")
	n.UpdateTime = field.NewTime(table, "updateTime")
	n.Fire = field.NewInt64(table, "fire")
	n.SumPrice = field.NewFloat64(table, "sumPrice")
	n.Lowprice = field.NewFloat64(table, "lowprice")
	n.Buyersnum = field.NewInt64(table, "buyersnum")
	n.Weekchange = field.NewFloat64(table, "weekchange")
	n.Daychange = field.NewFloat64(table, "daychange")

	n.fillFieldMap()

	return n
}

func (n *nftCollection) WithContext(ctx context.Context) INftCollectionDo {
	return n.nftCollectionDo.WithContext(ctx)
}

func (n nftCollection) TableName() string { return n.nftCollectionDo.TableName() }

func (n nftCollection) Alias() string { return n.nftCollectionDo.Alias() }

func (n *nftCollection) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := n.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (n *nftCollection) fillFieldMap() {
	n.fieldMap = make(map[string]field.Expr, 24)
	n.fieldMap["id"] = n.ID
	n.fieldMap["userId"] = n.UserID
	n.fieldMap["logoPath"] = n.LogoPath
	n.fieldMap["coverPath"] = n.CoverPath
	n.fieldMap["bannerPath"] = n.BannerPath
	n.fieldMap["name"] = n.Name
	n.fieldMap["symbol"] = n.Symbol
	n.fieldMap["link"] = n.Link
	n.fieldMap["details"] = n.Details
	n.fieldMap["type"] = n.Type
	n.fieldMap["royalties"] = n.Royalties
	n.fieldMap["chainPlatCert"] = n.ChainPlatCert
	n.fieldMap["isIn"] = n.IsIn
	n.fieldMap["inTime"] = n.InTime
	n.fieldMap["outTime"] = n.OutTime
	n.fieldMap["isCert"] = n.IsCert
	n.fieldMap["createTime"] = n.CreateTime
	n.fieldMap["updateTime"] = n.UpdateTime
	n.fieldMap["fire"] = n.Fire
	n.fieldMap["sumPrice"] = n.SumPrice
	n.fieldMap["lowprice"] = n.Lowprice
	n.fieldMap["buyersnum"] = n.Buyersnum
	n.fieldMap["weekchange"] = n.Weekchange
	n.fieldMap["daychange"] = n.Daychange
}

func (n nftCollection) clone(db *gorm.DB) nftCollection {
	n.nftCollectionDo.ReplaceDB(db)
	return n
}

type nftCollectionDo struct{ gen.DO }

type INftCollectionDo interface {
	gen.SubQuery
	Debug() INftCollectionDo
	WithContext(ctx context.Context) INftCollectionDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	As(alias string) gen.Dao
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) INftCollectionDo
	Not(conds ...gen.Condition) INftCollectionDo
	Or(conds ...gen.Condition) INftCollectionDo
	Select(conds ...field.Expr) INftCollectionDo
	Where(conds ...gen.Condition) INftCollectionDo
	Order(conds ...field.Expr) INftCollectionDo
	Distinct(cols ...field.Expr) INftCollectionDo
	Omit(cols ...field.Expr) INftCollectionDo
	Join(table schema.Tabler, on ...field.Expr) INftCollectionDo
	LeftJoin(table schema.Tabler, on ...field.Expr) INftCollectionDo
	RightJoin(table schema.Tabler, on ...field.Expr) INftCollectionDo
	Group(cols ...field.Expr) INftCollectionDo
	Having(conds ...gen.Condition) INftCollectionDo
	Limit(limit int) INftCollectionDo
	Offset(offset int) INftCollectionDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) INftCollectionDo
	Unscoped() INftCollectionDo
	Create(values ...*model.NftCollection) error
	CreateInBatches(values []*model.NftCollection, batchSize int) error
	Save(values ...*model.NftCollection) error
	First() (*model.NftCollection, error)
	Take() (*model.NftCollection, error)
	Last() (*model.NftCollection, error)
	Find() ([]*model.NftCollection, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.NftCollection, err error)
	FindInBatches(result *[]*model.NftCollection, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.NftCollection) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) INftCollectionDo
	Assign(attrs ...field.AssignExpr) INftCollectionDo
	Joins(fields ...field.RelationField) INftCollectionDo
	Preload(fields ...field.RelationField) INftCollectionDo
	FirstOrInit() (*model.NftCollection, error)
	FirstOrCreate() (*model.NftCollection, error)
	FindByPage(offset int, limit int) (result []*model.NftCollection, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) INftCollectionDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (n nftCollectionDo) Debug() INftCollectionDo {
	return n.withDO(n.DO.Debug())
}

func (n nftCollectionDo) WithContext(ctx context.Context) INftCollectionDo {
	return n.withDO(n.DO.WithContext(ctx))
}

func (n nftCollectionDo) ReadDB() INftCollectionDo {
	return n.Clauses(dbresolver.Read)
}

func (n nftCollectionDo) WriteDB() INftCollectionDo {
	return n.Clauses(dbresolver.Write)
}

func (n nftCollectionDo) Clauses(conds ...clause.Expression) INftCollectionDo {
	return n.withDO(n.DO.Clauses(conds...))
}

func (n nftCollectionDo) Returning(value interface{}, columns ...string) INftCollectionDo {
	return n.withDO(n.DO.Returning(value, columns...))
}

func (n nftCollectionDo) Not(conds ...gen.Condition) INftCollectionDo {
	return n.withDO(n.DO.Not(conds...))
}

func (n nftCollectionDo) Or(conds ...gen.Condition) INftCollectionDo {
	return n.withDO(n.DO.Or(conds...))
}

func (n nftCollectionDo) Select(conds ...field.Expr) INftCollectionDo {
	return n.withDO(n.DO.Select(conds...))
}

func (n nftCollectionDo) Where(conds ...gen.Condition) INftCollectionDo {
	return n.withDO(n.DO.Where(conds...))
}

func (n nftCollectionDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) INftCollectionDo {
	return n.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (n nftCollectionDo) Order(conds ...field.Expr) INftCollectionDo {
	return n.withDO(n.DO.Order(conds...))
}

func (n nftCollectionDo) Distinct(cols ...field.Expr) INftCollectionDo {
	return n.withDO(n.DO.Distinct(cols...))
}

func (n nftCollectionDo) Omit(cols ...field.Expr) INftCollectionDo {
	return n.withDO(n.DO.Omit(cols...))
}

func (n nftCollectionDo) Join(table schema.Tabler, on ...field.Expr) INftCollectionDo {
	return n.withDO(n.DO.Join(table, on...))
}

func (n nftCollectionDo) LeftJoin(table schema.Tabler, on ...field.Expr) INftCollectionDo {
	return n.withDO(n.DO.LeftJoin(table, on...))
}

func (n nftCollectionDo) RightJoin(table schema.Tabler, on ...field.Expr) INftCollectionDo {
	return n.withDO(n.DO.RightJoin(table, on...))
}

func (n nftCollectionDo) Group(cols ...field.Expr) INftCollectionDo {
	return n.withDO(n.DO.Group(cols...))
}

func (n nftCollectionDo) Having(conds ...gen.Condition) INftCollectionDo {
	return n.withDO(n.DO.Having(conds...))
}

func (n nftCollectionDo) Limit(limit int) INftCollectionDo {
	return n.withDO(n.DO.Limit(limit))
}

func (n nftCollectionDo) Offset(offset int) INftCollectionDo {
	return n.withDO(n.DO.Offset(offset))
}

func (n nftCollectionDo) Scopes(funcs ...func(gen.Dao) gen.Dao) INftCollectionDo {
	return n.withDO(n.DO.Scopes(funcs...))
}

func (n nftCollectionDo) Unscoped() INftCollectionDo {
	return n.withDO(n.DO.Unscoped())
}

func (n nftCollectionDo) Create(values ...*model.NftCollection) error {
	if len(values) == 0 {
		return nil
	}
	return n.DO.Create(values)
}

func (n nftCollectionDo) CreateInBatches(values []*model.NftCollection, batchSize int) error {
	return n.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (n nftCollectionDo) Save(values ...*model.NftCollection) error {
	if len(values) == 0 {
		return nil
	}
	return n.DO.Save(values)
}

func (n nftCollectionDo) First() (*model.NftCollection, error) {
	if result, err := n.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.NftCollection), nil
	}
}

func (n nftCollectionDo) Take() (*model.NftCollection, error) {
	if result, err := n.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.NftCollection), nil
	}
}

func (n nftCollectionDo) Last() (*model.NftCollection, error) {
	if result, err := n.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.NftCollection), nil
	}
}

func (n nftCollectionDo) Find() ([]*model.NftCollection, error) {
	result, err := n.DO.Find()
	return result.([]*model.NftCollection), err
}

func (n nftCollectionDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.NftCollection, err error) {
	buf := make([]*model.NftCollection, 0, batchSize)
	err = n.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (n nftCollectionDo) FindInBatches(result *[]*model.NftCollection, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return n.DO.FindInBatches(result, batchSize, fc)
}

func (n nftCollectionDo) Attrs(attrs ...field.AssignExpr) INftCollectionDo {
	return n.withDO(n.DO.Attrs(attrs...))
}

func (n nftCollectionDo) Assign(attrs ...field.AssignExpr) INftCollectionDo {
	return n.withDO(n.DO.Assign(attrs...))
}

func (n nftCollectionDo) Joins(fields ...field.RelationField) INftCollectionDo {
	for _, _f := range fields {
		n = *n.withDO(n.DO.Joins(_f))
	}
	return &n
}

func (n nftCollectionDo) Preload(fields ...field.RelationField) INftCollectionDo {
	for _, _f := range fields {
		n = *n.withDO(n.DO.Preload(_f))
	}
	return &n
}

func (n nftCollectionDo) FirstOrInit() (*model.NftCollection, error) {
	if result, err := n.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.NftCollection), nil
	}
}

func (n nftCollectionDo) FirstOrCreate() (*model.NftCollection, error) {
	if result, err := n.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.NftCollection), nil
	}
}

func (n nftCollectionDo) FindByPage(offset int, limit int) (result []*model.NftCollection, count int64, err error) {
	result, err = n.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = n.Offset(-1).Limit(-1).Count()
	return
}

func (n nftCollectionDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = n.Count()
	if err != nil {
		return
	}

	err = n.Offset(offset).Limit(limit).Scan(result)
	return
}

func (n nftCollectionDo) Scan(result interface{}) (err error) {
	return n.DO.Scan(result)
}

func (n nftCollectionDo) Delete(models ...*model.NftCollection) (result gen.ResultInfo, err error) {
	return n.DO.Delete(models)
}

func (n *nftCollectionDo) withDO(do gen.Dao) *nftCollectionDo {
	n.DO = *do.(*gen.DO)
	return n
}
